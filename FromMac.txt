
Конфигурация:
      Platform: macOS 10.12.6 (16G29)
      Compiler: Apple LLVM version 9.0.0 (clang-900.0.37)
      IDE: Xcode Version 9.0 (9A235)




/*
  Комментарии - полная лажа, но может хоть что-то
  Ща закомичу -> сложу вещи -> спать 
*/


      ЗАДАНИЕ №1

    а)  y = -x-1;

     0x100000d24 <+4>:  xorl   %eax, %eax // чтобы понять что вообще происходит

    0x100000d26 <+6>:  movl   %edi, -0x4(%rbp) //толкаем число в базовый указатель стека
->  0x100000d29 <+9>:  subl   -0x4(%rbp), %eax  // отнимаем это число от 0
    0x100000d2c <+12>: subl   $0x1, %eax  // отнимаем 1
    0x100000d2f <+15>: movl   %eax, -0x8(%rbp) записываем обратно в стек

    0x100000d32 <+18>: movl   -0x8(%rbp), %eax // нужно ли это?




    б) y = x*13;

    0x100000d44 <+4>:  movl   %edi, -0x4(%rbp)
->  0x100000d47 <+7>:  imull  $0xd, -0x4(%rbp), %edi  // умножить 0xd  на -0x4(%rbp) и присвоить edi
    0x100000d4b <+11>: movl   %edi, -0x8(%rbp) // запись обратно в стек

    0x100000d4e <+14>: movl   -0x8(%rbp), %eax


    в)y = (x<7)?0:x;

 -> 0x100000d67 <+7>:  cmpl   $0x7, -0x4(%rbp)  // сравниваем
    0x100000d6b <+11>: jge    0x100000d7b               ; <+27> at main.cpp:24 // если значение больше или равно
    0x100000d71 <+17>: xorl   %eax, %eax // 0
    0x100000d73 <+19>: movl   %eax, -0xc(%rbp) // то присваиваем 0
    0x100000d76 <+22>: jmp    0x100000d81               ; <+33> at main.cpp:24 // безусловный переход на нужный участок (сюда можем и не дойти)
    0x100000d7b <+27>: movl   -0x4(%rbp), %eax помещаем x
    0x100000d7e <+30>: movl   %eax, -0xc(%rbp) записываем результат обратно в стек




    ЗАДАНИЕ №3
    Глобальные переменные (lea - если нкжно поместить смещение )
    Отличие lea от mov состоит в том,что используется механизм блока адресации процессора, а не арифметико-логического блока.

    ? - значит "Вроде как не надо" или "нипанятна" или "не могу понять зачем"
     1)Y = -X-1;


     0x100000e23 <+51>:  movl   $0x1, %edi // - это не надо

     0x100000e28 <+56>:  xorl   %ecx, %ecx // делаем 0

     0x100000e2a <+58>:  subl   0x208(%rip), %ecx         ; X  // вычитаем Х из 0
     0x100000e30 <+64>:  subl   $0x1, %ecx          // вычитаем 1
     0x100000e33 <+67>:  movl   %ecx, 0x203(%rip)           ; Y  // записываем Y

     0x100000e39 <+73>:  movl   %eax, -0x18(%rbp)//? - не надо

2)char:   y = -x-1;

/////////////////////////////////////////////////////////////////////////////////////////////////////
      вызов функции
      ex3((char)1);

      0x100000e39 <+73>:  movl   %eax, -0x18(%rbp)
      0x100000e3c <+76>:  callq  0x100000f6c               ; symbol stub for: char ex3<char>(char)

/////////////////////////////////////////////////////////////////////////////////////////////////////


    0x100000eb4 <+4>:  movb   %dil, %al  // не надо

    0x100000eb7 <+7>:  xorl   %edi, %edi //0
    0x100000eb9 <+9>:  movb   %al, -0x1(%rbp)
    ->  0x100000ebc <+12>: movsbl -0x1(%rbp), %ecx // знаковое расширение (Аналог movsx у Intel)
    0x100000ec0 <+16>: subl   %ecx, %edi  // 0 - ecx  = -x
    0x100000ec2 <+18>: subl   $0x1, %edi //  - 1
    0x100000ec5 <+21>: movb   %dil, %al
    0x100000ec8 <+24>: movb   %al, -0x2(%rbp) // куча "присвоить"

3)ex3((short)1);

// а вот так кланг ставит 0 в ячейку

  0x100000ee7 <+7>:  xorl   %edi, %edi // 0
  0x100000ee9 <+9>:  movw   %ax, -0x2(%rbp)

   0x100000eed <+13>: movswl -0x2(%rbp), %ecx // приведение к  int
   0x100000ef1 <+17>: subl   %ecx, %edi  // -x
   0x100000ef3 <+19>: subl   $0x1, %edi // -x -1
   0x100000ef6 <+22>: movw   %di, %ax //  берем 16 бит?
   0x100000ef9 <+25>: movw   %ax, -0x4(%rbp)

   0x100000efd <+29>: movswl -0x4(%rbp), %eax // не надо

4) ex3((long)1);

        банальное присвоение 0
      /////////////////////////////////////
      0x100000f14 <+4>:  xorl   %eax, %eax
      0x100000f16 <+6>:  movl   %eax, %ecx
      /////////////////////////////////////

    0x100000f18 <+8>:  movq   %rdi, -0x8(%rbp)
->  0x100000f1c <+12>: subq   -0x8(%rbp), %rcx // -x
    0x100000f20 <+16>: subq   $0x1, %rcx // -x - 1
    0x100000f24 <+20>: movq   %rcx, -0x10(%rbp) // обратно в стек

    0x100000f28 <+24>: movq   -0x10(%rbp), %rax // - не надо


5) ex3((long long)1);
          // здесь вероятно  xorl %rcx, %rcx

          0x100000f38 <+8>:  movq   %rdi, -0x8(%rbp)

      ->  0x100000f3c <+12>: subq   -0x8(%rbp), %rcx
          0x100000f40 <+16>: subq   $0x1, %rcx

          0x100000f44 <+20>: movq   %rcx, -0x10(%rbp)

 6) ex3((long double)1);
// скопирую весь код
          0x100000f51 <+1>:  movq   %rsp, %rbp
          0x100000f54 <+4>:  fldt   0x10(%rbp) //Загрузка long double в вершину стека
          0x100000f57 <+7>:  fstpt  -0x10(%rbp) // Сохранение вершины стека в память с выталкиванием (описание команд без t)
      ->  0x100000f5a <+10>: fldt   -0x10(%rbp) //Загрузка операнда в вершину стека
          0x100000f5d <+13>: fld1    /// загрузка 1 в вершину стека (1 является константой)
          0x100000f5f <+15>: fchs  // Изменение знака
          0x100000f61 <+17>: fsubp  %st(1) // Вычитание вещественное реверсивное с выталкиванием
          0x100000f63 <+19>: fstpt  -0x20(%rbp)  // сохр вершину стека
          0x100000f66 <+22>: fldt   -0x20(%rbp) // загрузить long double в вершину







        ЗАДАНИЕ №4
/// вообще не вижу разницы

        0x100000dfd <+13>:  movl   $0x0, -0x4(%rbp)
    ->  0x100000e04 <+20>:  callq  0x100000d20               ; ex1a at main.cpp:8


        0x100000d24 <+4>:  xorl   %eax, %eax
        0x100000d26 <+6>:  movl   %edi, -0x4(%rbp)
    ->  0x100000d29 <+9>:  subl   -0x4(%rbp), %eax
        0x100000d2c <+12>: subl   $0x1, %eax
        0x100000d2f <+15>: movl   %eax, -0x8(%rbp)

        0x100000d32 <+18>: movl   -0x8(%rbp), %eax
        0x100000d35 <+21>: popq   %rbp
        0x100000d36 <+22>: retq





        ЗАДАНИЕ №5

           0x100000e7e <+142>: movsd  0x122(%rip), %xmm0        ; xmm0 = mem[0],zero


        ->  0x100000e86 <+150>: fstpt  -0x3c(%rbp)
            0x100000e89 <+153>: callq  0x100000d90               ; ex5 at main.cpp:44


            Внутри функции
            0x100000dab <+27>: movsd  -0x8(%rbp), %xmm0         ; xmm0 = mem[0],zero // пересылка в 128 битный регистр А
            0x100000db0 <+32>: movd   %xmm0, %rcx  // переслать 32 бита ?
            0x100000db5 <+37>: xorq   %rax, %rcx
            0x100000db8 <+40>: movd   %rcx, %xmm0
            0x100000dbd <+45>: subsd  %xmm1, %xmm0  // вычитаем
            0x100000dc1 <+49>: movsd  %xmm0, -0x10(%rbp) // толкаем в стек

            0x100000dc6 <+54>: movsd  -0x10(%rbp), %xmm0   // В регистр xmm0 записываются данные из стека, но это не надо




        ЗАДАНИЕ №6


    0x100000dd4 <+4>:  xorl   %eax, %eax // 0
    0x100000dd6 <+6>:  movl   %edi, -0x4(%rbp) // записываем
->  0x100000dd9 <+9>:  subl   -0x4(%rbp), %eax // -x
    0x100000ddc <+12>: subl   $0x1, %eax // -x -1
    0x100000ddf <+15>: movl   %eax, 0x25b(%rip) // пишем в указатель команд???
